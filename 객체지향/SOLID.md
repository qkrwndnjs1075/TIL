# 객체지향 5원칙

## 무엇일까?

객체지향 5원칙은 SOLID 원칙이라고도 부르며,
객체지향 프로그래밍을 하며 꼭 지켜야하는 5개의 원칙이다.

SOLID는 각 5가지원칙의 첫글자를 따서 붙인 이름이다.

- **S**RP(Single Responsibility Principle, 단일 책임 원칙) 
- **O**CP(Open-Closed Principle, 개방 폐쇄 원칙)
- **I**SP(Interface Segregation Principle, 인터페이스 분리 원칙)
- **L**SP(Liskov Substitution Principle, 리스코프 치환 원칙)
- **D**IP(Dependency Inversion Principle, 의존성 역전 원칙)

## **S**RP(Single Responsibility Principle, 단일 책임 원칙)

단일 책임 원칙은 하나의 클래스는 하나의 책임만 갖는다는 것이다.

여기서 말하는 책임은 기능에 대한 책임이다.

만약 이를 어기게 된다면, 기능수정을 할때 연쇄적으로 코드를 변경해야한다.
<br/>

![image](https://github.com/qkrwndnjs1075/TIL/assets/163108207/05ec113f-04a6-41ba-9c97-8dba1b7981b2)

위의 남자 클래스에 SRP를 적용한다고 가정해보자.

다음과 같이 책임을 분배하여 클래스를 분리할 수 있을 것이다.

![images_falling_star3_post_8ffa5565-8755-4c5d-8593-1d473f261e58_image](https://github.com/qkrwndnjs1075/TIL/assets/163108207/7f891c37-af11-43b2-92fb-a8e099b0c1df)

<br/>

## **O**CP(Open-Closed Principle, 개방 폐쇄 원칙)

개방 폐쇄 원칙은 코드의 확장은 가능하게 하되, 코드의 직접적 수정은 변경하지 않게 해야한다는 것이다.

이는 상속과 다형성을 이용하면 쉽게 준수할 수 있다.
Overriding을 이용하여 코드를 건드리지 않고 확장할 수있는 것이다

이를 통해 코드의 연쇄적 변경을 막을 수 있다.

<br/>

![image](https://github.com/qkrwndnjs1075/TIL/assets/163108207/1b0aaf74-e4f4-4620-bde1-071a03921ab8)

<br>
위의 운전자 클래스는 마티즈 클래스와 소나타 클래스의 변화에 따라 행동이 의존적으로 변하게 된다.
<br>

다음과 같이 마티즈 클래스와 소나타 클래스 위에 자동차라는 상위 클래스를 두면, 운전자는 마티즈와 소나타 클래스의 변경사항에 영향을 받지 않을 수 있다.

![1](https://github.com/qkrwndnjs1075/TIL/assets/163108207/92411de8-878b-4ad7-a722-dc1418c37e16)

이처럼 클래스를 설계할 때 변할 부분과 변하지 않을 부분을 명확히 구분해야한다.

변할 수 있는 부분은 추상화하여 상속하는 클래스가 의존할 수 있게 코드를 작성한다.

<br/>

## **I**SP(Interface Segregation Principle, 인터페이스 분리 원칙)

인터페이스 분리 원칙은 자신이 사용하는 메서드에만 의존해야하는 것이다.

예를 들어, 추상 클래스 A의 a, b, c, 메서드가 있다. 여기서 A를 상속받은 B클래스는 a메서드만 사용한다.
하지만 A클래스의 추상 메서드인 a, b, c 모두 기능을 구현해야한다.
얼마나 의미없는 낭비인가..
이를 올바르게 해결하는 방법은 추상메서드 a, b, c를 인터페이스로 분리하여
B 클래스가 필요한 a메서드만 상속받아 구현하는 것이다.

이를 통해 불필요한 의존을 없애고, 확장성을 향상시킬 수 있다.

![image](https://github.com/qkrwndnjs1075/TIL/assets/163108207/730c95b9-df87-4c10-a134-763f4ef92027)
<br>
위의 SRP 예제에서 남자 클래스를 단일 책임을 갖는 클래스들로 나누었다. 이것은 너무 많은 클래스 구현을 불러 온다.

ISP를 적용하면 다양한 역할을 인터페이스로 만들고, 남자 클래스는 그 인터페이스를 구현한 클래스로 만들 수 있다.
<br>
![1](https://github.com/qkrwndnjs1075/TIL/assets/163108207/33bb6eb6-c905-44da-a9f1-c658552780e4)
<br>




## **L**SP(Liskov Substitution Principle, 리스코프 치환 원칙)

상위타입과 그 하위타입이 있을때, 상위타입 대신 하위타입을 넣어도 기능이 정상작동 해야하는 것이다.

이 원칙이 지켜지지 않는 대표적인 예시로는 직사각형과 정사각형이 있다.
정사각형을 직사각형의 특이 케이스로 보고, 직사각형의 하위 타입(상속)으로 설정해 주었다.
하지만 정사각형은 가로와 세로의 길이가 같기때문에,
가로의 길이를 설정할 때 세로의 길이또한 같게 초기화하게 메서드를 재정의하고, 
넓이를 구하게 된다면, 넓이가 정상적으로 나오지 않는 경우가 생긴다.

이 원칙이 위배되면, 코드가 어디가 잘못되었는지 파악하기가 힘들다.

<br>

![image](https://github.com/qkrwndnjs1075/TIL/assets/163108207/4beb40be-c5c1-47f9-aab0-56edf8f5bef6)
<br>
쉬운 예시를 하나 더 들자면, 자동차 인터페이스의 엑셀은 앞으로 가게 하는 기능인데 이를 뒤로 가게 구현하면 LSP를 위반한 것이다. 느리더라도 앞으로 가게 구현해야 한다.


### DIP(Dependency Inversion Principle)

> "추상화된 것은 구체적인 것에 의존하면 안된다. 구체적인 것이 추상화된 것에 의존해야 한다."
> 

쉽게 이야기해서 구현 클래스에 의존하지 말고, 인터페이스에 의존하라는 뜻이다. 구현체에 의존하게 되면 변경이 아주 어려워진다.

즉, 인터페이스를 적극적으로 활용하라는 의미이다.

![image](https://github.com/qkrwndnjs1075/TIL/assets/163108207/e110c63b-fcfd-409b-9fad-58b672415cc5)


자동차는 스노우타이어에 의존하고 있다.

![1](https://github.com/qkrwndnjs1075/TIL/assets/163108207/026ede9c-71cd-44a9-93fd-d4404a701c45)


해당 관계를 타이어 인터페이스로 역전 시킨다. 이것이 의존성 주입(DI)이다.

상위클래스일 수록, 인터페이스일 수록, 추상 클래스일 수록 변하지 않을 가능성이 크다. 하위클래스나 구체클래스가 아닌 더 추상적인 것에 의존하라는 것이 의존 역전 원칙이다.

